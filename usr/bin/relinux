#!/bin/bash
#
# Relinux is a remastering script based on remastersys
# It is made to be simpler, better, more customizable,
# better documented, up to date with the latest systems,
# more user friendly, and accessable by many linux distributions
#
# Copyright 2011/2012 under the GNU GPLv3 license
# Joel Leclerc (lkjoel)
#
# Original Script (remastersys) Copyright 2007-2011 Tony "Fragadelic" Brijeski <tb6517@yahoo.com>
# Some parts were copied from the original script
#
# A few useful variables
export DIR=/etc/relinux/
export CONFIGFILE=$DIR/relinux.conf
export DISPPROGNAME="Relinux"
export PROGNAME="relinux"
export PROGVERSION="0.3"
export POSSIBLEARGS="clean fullclean squashfs onlyiso config iso"
export TRUE=0
export FALSE=1
export UNKNOWN=2
export WUT=3
export NULL=/dev/null
export SUDO=""
export OK='[\e[32m  OK  \e[0m]'
export FAIL='[\e[31m FAIL \e[0m]'
export PREVWORKSPACE=""
# Checks if a variable is inside a list
varin() {
	LIST=$1
	VAR=$2
	y=$FALSE
	for i in $LIST
	do
		if [[ $i == $VAR ]]
		then
			y=$TRUE
		fi
	done
	echo $y
	return $y
}
# Echoes the return code
echr() {
	"$@" &>$NULL
	STATUS=$?
	echo $STATUS
	return $STATUS
}
# Return the echo
rete() {
	return `$@`
}
# NOT operator
not() {
	t=`echr "$@"`
	if [ $t -eq $TRUE ]
	then
		return $FALSE
	elif [ $t -eq $FALSE ]
	then
		return $TRUE
	fi
	return $WUT
}
# Checks if the user is root
isroot() {
	if varin "`groups`" "root"
	then
		return $TRUE
	else
		return $FALSE
	fi
	return $WUT
}
if isroot
then
	SUDO="sudo "
fi
# Prints a character N times
printchar()
{
	x=0
	while [ $x -lt $1 ]
	do
		echo -n "$2"
		x=$(($x+1))
	done
}
# Prints out the usage of Relinux
usage()
{
	progname=`printchar ${#PROGNAME} ' '`
	echo -e "Usage of $PROGNAME is as follows:"
	echo -e " "
	echo -e "   sudo $PROGNAME clean|iso|squashfs|onlyiso " \
	"[configfile]"
	echo -e " "
	echo -e " "
	echo -e "Examples:"
	echo -e " "
	echo -e "   sudo $PROGNAME clean [configfile]              " \
	" Cleans up files made by $PROGNAME"
	echo -e " "
	echo -e "   sudo $PROGNAME fullclean [configfile]          " \
	" Cleans up files made by $PROGNAME, including the ISO file"
	echo -e "   sudo $PROGNAME squashfs [configfile]           " \
	" Generates a .squashfs file from your system"
	echo -e " "
	echo -e "   sudo $PROGNAME onlyiso [configfile]            " \
	" Generates a .iso file based on the .squashfs file generated by" \
	" the previous listed command"
	echo -e "        $progname                                 " \
	" If configfile is given, settings will be used from that file"
	echo -e " "
	echo -e "   sudo $PROGNAME iso [configfile]                " \
	" Runs the last 2 listed commands"
	echo -e " "
	echo -e "   sudo $PROGNAME config                          " \
	" Generates a configuration file in the current directory"
}
# Math "max" function
max()
{
	if [ $1 -gt $2 ]
	then
		echo $1
	else
		echo $2
	fi
	return $TRUE
}
# Math "min" function
min()
{
	if [ $1 -lt $2 ]
	then
		echo $1
	else
		echo $2
	fi
	return $TRUE
}
# Helper function for installing/removing packages
_helperPackageOp()
{
	DISPOP="$1"
	OP="$2"
	DISP="$3"
	PAK="$4"
	if [ $# -lt 5 ]
	then
		set $DISPOP $OP $DISP $PAK $FALSE
	fi
	CRITICAL=$5
	if [ $# -lt 6 ]
	then
		set $DISPOP $OP $DISP $PAK $CRITICAL 0
	fi
	MINSPACES=$6
	SPACES=$(($MINSPACES-${#DISP}))
	if [ ${#DISP} -ge $MINSPACES ]
	then
		SPACES=0
	fi
	echo -en "$DISPOP $DISP`printchar $SPACES ' '` "
	$SUDO apt-get $OP -y --force-yes -qq $PAK &>$NULL
	STATUS=$?
	if [ $STATUS -eq 0 ]
	then
		echo -e "$OK"
	else
		echo -e "$FAIL"
		if [ $CRITICAL -eq $TRUE ]
		then
			exit 1
		fi
	fi
	return $STATUS
}
# Installs a package
installpackage()
{
	_helperPackageOp "Installing  " install $@
	return $?
}
# Removes a package
removepackage()
{
	_helperPackageOp "Removing    " purge $@
	return $?
}
#
# Checks if a package is installed, and if not, install it.
checkbin()
{
	if [ $# -lt 2 ]
	then
		app=$1
		set $app $app $app $FALSE 0
	elif [ $# -lt 3 ]
	then
		app=$1
		package=$2
		set $app $app $package $FALSE 0
	fi
	APP="$1"
	DISP="$2"
	PAK="$3"
	STATUS=$TRUE
	MINSPACES=$5
	SPACES=$(($MINSPACES-${#DISP}))
	if [ ${#DISP} -ge $MINSPACES ]
	then
		SPACES=0
	fi
	echo -en 'Checking for '"$DISP`printchar $SPACES ' '` "
	which $APP &>$NULL
	if [ $? -eq $TRUE ]
	then
		echo -e "$OK"
	else
		#echo -e "$FAIL"
		echo -e "\r"
		installpackage $DISP $PAK $4 $5
		STATUS=$?
	fi
	return $STATUS
}
# Checks if a package is installed by a file, and if not, install it
checkfile()
{
	if [ $# -lt 4 ]
	then
		set $1 $2 $3 $FALSE 0
	elif [ $# -lt 5 ]
	then
		set $1 $2 $3 $4 0
	fi
	FILE="$1"
	DISP="$2"
	PAK="$3"
	STATUS=$TRUE
	MINSPACES=$5
	SPACES=$(($MINSPACES-${#DISP}))
	if [ ${#DISP} -ge $MINSPACES ]
	then
		SPACES=0
	fi
	echo -en 'Checking for '"$DISP`printchar $SPACES ' '` "
	if [ -f $FILE ]
	then
		echo -e "$OK"
	else
		#echo "$FAIL"
		echo -e "\r"
		installpackage $DISP $PAK $4 $5
		STATUS=$?
	fi
	return $STATUS
}
# Checks if a package is installed by using DPKG
checkpackage()
{
	dpkg -l | awk '{print $2}' | grep '^'"$1"'$' &>$NULL
	return $?
}
# Checks if a list of packages are installed, and if not, install them
checklist()
{
	count=0
	current=0
	type=$NULL
	first=$NULL
	second=$NULL
	third=$NULL
	m=0
	for i in $*
	do
		if [ $current -eq 2 ]
		then
			m=`max $m ${#i}`
		elif [ $current -eq 3 ]
		then
			current=-1
		fi
		current=$(($current+1))
	done
	current=0
	for i in $*
	do
		if [ $current -eq 0 ]
		then
			type=$i
		elif [ $current -eq 1 ]
		then
			first=$i
		elif [ $current -eq 2 ]
		then
			second=$i
		elif [ $current -eq 3 ]
		then
			third=$i
			current=-1
			if [[ $type == "b" ]]
			then
				checkbin $first $second $third $FALSE $m
			elif [[ $type == "f" ]]
			then
				checkfile $first $second $third $FALSE $m
			fi
		fi
		current=$(($current+1))
	done
	return $TRUE
}
# Creates a directory safely
makedir()
{
	if [ ! -d $1 ]
	then
		mkdir -p $1
		return $?
	else
		return $FALSE
	fi
	return $WUT
}
# Boxes text
box()
{
	export count=${#1}
	export HASHNUM=$(($count+6))
	printchar $HASHNUM "#"
	echo
	echo '## '$1' ##'
	printchar $HASHNUM "#"
	echo
	return $TRUE
}
# Fixes an array
fixarray()
{
	a=""
	for i in $@
	do
		a="$a $i"
	done
	echo $a
	return $TRUE
}
# Returns the length of an array
len()
{
	c=0
	for i in $@
	do
		c=$(($c+1))
	done
	echo $c
	return $TRUE
}
# Returns the last item of an array
lastitem()
{
	l=`len $@`
	if [ $l -lt 1 ]
	then
		echo ""
		return $TRUE
	fi
	echo `fixarray $@` | cut -d" " -f$l
	return $TRUE
}
# Pops the last item of an array
pop()
{
	l_=`len $@`
	l=$(($l-1))
	if [ $l -lt 1 ]
	then
		echo ""
		return $TRUE
	fi
	echo `fixarray $@` | cut -d" " -f-$l
	return $TRUE
}
# Empty a file
emptyfile()
{
	rm -f $@
	touch $@
	return $TRUE
}
# Empty a directory
emptydir()
{
	rm -rf $@
	makedir $@
	return $?
}
# Checks if a variable is a number or not
isnumber()
{
	[ $1 -eq $1 ] &>$NULL
	if [ $? -eq 0 ]
	then
		return $TRUE
	else
		return $FALSE
	fi
	return $WUT
}
# Simple uppercase conversion
toupper()
{
	echo "$*" | tr '[:lower:]' '[:upper:]'
	return $TRUE
}
# Simple lowercase conversion
tolower()
{
	echo "$*" | tr '[:upper:]' '[:lower:]'
	return $TRUE
}
# Returns the first character of a string
firstchar()
{
	echo "$*" | sed 's/\(.\).*/\1/g'
	return $TRUE
}
# Parses Yes/No answers in relinux.conf
parseboolean()
{
	OPT_="`tolower $1`"
	OPT="`firstchar $OPT_`"
	YES="y"
	NO="n"
	OPTTRUE="t"
	OPTFALSE="f"
	if [[ $OPT == $YES || $OPT == $OPTTRUE ]]
	then
		return $TRUE
	elif [[ $OPT == $NO || $OPT == $OPTFALSE ]]
	then
		return $FALSE
	else
		return $UNKNOWN
	fi
	return $WUT
}
# Switches to a new "workspace" (i.e. new directory)
new_workspace() {
	PREVWORKSPACE="$PREVWORKSPACE `pwd`"
	echo -n "NW"
	pwd
	cd $1
	return $TRUE
}
# Switches back to the old "workspace"
prev_workspace() {
	cd `lastitem $PREVWORKSPACE`
	echo -n "PW"
	pwd
	PREVWORKSPACE_="`pop $PREVWORKSPACE`"
	PREVWORKSPACE="$PREVWORKSPACE_"
	return $TRUE
}
# Give an error message that should never be shown
wutmsg()
{
	echo "Wut? Something screwed up pretty badly, as you should never see this"'!'
	echo "Please send an error report to relinux. While you are waiting, see if the manual"\
"can help:"
	echo "============"
	echo
	usage
	exit 1
}
# If the user gave an unknown argument or the user is not root, show the usage message
# and exit
if [ `varin "$POSSIBLEARGS" "$1"` -eq $FALSE -o `echr isroot` -ne $TRUE ]
then
	usage
	exit 1
fi
# Check if all apps needed are installed
checklist \
b bash bash bash \
b sed sed sed \
b find find findutils \
b passwd passwd passwd \
b rsync rsync rsync \
b mount mount mount \
b eject eject eject \
f /usr/lib/libdebian-installer.so.4.0.7 libdebian-installer4 libdebian-installer4 \
f /boot/memtest86+.bin memtest86+ memtest86+ \
b casper-login casper casper \
b mksquashfs mksquashfs squashfs-tools \
b unsquashfs unsquashfs squashfs-tools \
b genisoimage genisoimage genisoimage \
b os-prober os-prober os-prober \
b ubiquity ubiquity ubiquity \
b user-setup user-setup user-setup \
b discover-config discover-config discover \
b laptop-detect laptop-detect laptop-detect \
b xterm xterm xterm \
b syslinux syslinux syslinux \
b fsck util-linux util-linux \
b xresprobe xresprobe xresprobe \
b archdetect archdetect archdetect-deb \
b lsinitramfs initramfs-tools initramfs-tools \
b dirname coreutils coreutils
# Check if the User configuration file is loaded
if [ $# -lt 2 ]
then
	export USERCONFIGFILE=$NULL
else
	export USERCONFIGFILE=$2
fi
# Load the relinux configuration file for defaults
. $CONFIGFILE
# Load the user configuration file
. $USERCONFIGFILE
# SquashFS checks
do_squashfs_checks()
{
	# Make sure that the SquashFS file exists
	if [ ! -f "$WORKDIR/ISOTMP/casper/filesystem.squashfs" ]; then
		echo "The CD filesystem is missing.  Either there was a problem "\
		"creating the compressed filesystem or you are trying to run "\
		"sudo relinux onlyiso before sudo relinux squashfs"
		return $FALSE
	fi
	# Make sure that the SquashFS file is under the iso9660 specification
	SQUASHFSSIZE=`wc -c $WORKDIR/ISOTMP/casper/filesystem.squashfs | \
	awk -F " " '{print $1}'`
	if [ $SQUASHFSSIZE -ge $((4*(1024**3))) ]; then
		echo " The compressed filesystem is larger than the iso9660 "\
		"specification allows for a single file. You must try to reduce the "\
		"amount of data you are making and try again."
		return $FALSE
	fi
	return $TRUE
}
# Generate the SquashFS file
cdfs() {
	############
	## STEP 1 ##
	############
	# Install/Remove all packages needed automatically
	#
	box 'STEP 1 of SquashFS'
	echo 'Installing/Removing all packages needed to install/remove'
	# Remove popularity-contest as it can break ubiquity
	removepackage "popularity-contest" popularity-contest
	# Checks if the desktop session is KDE or other
	if [ ! -z $KDE_FULL_SESSION ]
	then
		# It is KDE, so install the KDE frontend for ubiquity and remove the GTK one
		installpackage "ubiquity-frontend-kde" ubiquity-frontend-kde
		removepackage "ubiquity-frontend-gtk" ubiquity-frontend-gtk
	else
		# It is not KDE, so install the GTK frontend for ubiquity and remove th KDE one
		installpackage "ubiquity-frontend-gtk" ubiquity-frontend-gtk
		removepackage "ubiquity-frontend-kde" ubiquity-frontend-kde
	fi
	############
	## STEP 2 ##
	############
	#
	# Create CD tree in $WORKDIR
	box 'STEP 2 of SquashFS'
	echo 'Creating CD tree in '"$WORKDIR"''
	if [ -d $WORKDIR ]
	then
		rm -rf $WORKDIR/ISOTMP/grub  # TODO: Is this actually needed?
		emptydir $WORKDIR/ISOTMP/isolinux
		emptydir $WORKDIR/ISOTMP/.disk
		emptydir $WORKDIR/dummysys/var/
		emptydir $WORKDIR/dummysys/etc/
	else
		makedir $WORKDIR/ISOTMP/casper
		makedir $WORKDIR/ISOTMP/preseed
		makedir $WORKDIR/ISOTMP/isolinux
		makedir $WORKDIR/ISOTMP/.disk
		makedir $WORKDIR/dummysys/dev
		makedir $WORKDIR/dummysys/etc
		makedir $WORKDIR/dummysys/proc
		makedir $WORKDIR/dummysys/tmp
		makedir $WORKDIR/dummysys/sys
		makedir $WORKDIR/dummysys/mnt
		makedir $WORKDIR/dummysys/media/cdrom
		makedir $WORKDIR/dummysys/var
		makedir $WORKDIR/dummysys/home
		chmod -R 1777 $WORKDIR/dummysys/tmp
	fi
	echo "Done"
	############
	## STEP 3 ##
	############
	#
	# Copy /var and /etc to $WORKDIR/dummysys, and exclude $EXCLUDES
	box 'STEP 3 of SquashFS'
	echo "Copying /etc and /var to a temporary directory so we can work on them"
	EXCLUDES="$EXCLUDES *.pid boot/grub*"
	if not parseboolean $KEEPRELINUX
	then
		EXCLUDES="$EXCLUDES etc/relinux* usr/bin/relinux "
		EXCLUDES="$EXCLUDES usr/doc/relinux*"
	fi
	if not parseboolean $KEEPLOG
	then
		EXCLUDES="$EXCLUDES *.log.* *.log"
	fi
	if not parseboolean $KEEPBACKUP
	then
		EXCLUDES="$EXCLUDES *.bak"
	fi
	if not parseboolean $KEEPOLD
	then
		EXCLUDES="$EXCLUDES *.[0-9].gz *.cache Cache *.bash_history"
		EXCLUDES="$EXCLUDES .thumbnails /tmp*"
	fi
	if not parseboolean $KEEPDEB
	then
		EXCLUDES="$EXCLUDES *.deb"
	fi
	if not parseboolean $BACKUPMODE
	then
		EXCLUDES="$EXCLUDES home"
	fi
	if not parseboolean $KEEPWORKDIR
	then
		EXCLUDES="$EXCLUDES $WORKDIR"
	fi
	# exclude-from patch by Hernan Foffani
	# (https://answers.launchpad.net/relinux/+question/177918)
	excludefrom=`tempfile`
	echo "$EXCLUDES" | tr ' ' '\n' > $excludefrom
	rsync --exclude-from=$excludefrom -a /var/. $WORKDIR/dummysys/var/.
	rsync --exclude-from=$excludefrom -a /etc/. $WORKDIR/dummysys/etc/.
	rm -f $excludefrom
	echo "Done. Removing unneeded files and editing others"
	# Switch to $WORKDIR/dummysys
	new_workspace $WORKDIR/dummysys
	# Switch to $WORKDIR/dummysys/etc
	new_workspace etc
	rm -rf X11/xorg.conf* resolv.conf hosts hostname timezone {m,fs}tab
	rm -rf udev/rules.d/70-persistent* cups/ssl/server.{crt,key}
	rm -rf ssh/ssh_host_{r,d}sa_key ssh/ssh_host_{r,d}sa_key.pub
	rm -rf group group- passwd passwd- shadow shadow- gshadow gshadow-
	rm -rf wicd/wired-settings.conf wicd/wireless-settings.conf
	rm -rf NetworkManager/system-connections/*
	emptyfile printcap
	emptyfile cups/printers.conf
	# Switch back to $WORKDIR/dummysys
	prev_workspace
	# Switch to $WORKDIR/dummysys/var
	new_workspace var
	rm -f `find run log mail spool lock backups tmp crash lib/ubiquity -type f`
	rm -f `find lib/apt/lists | grep -v ".gpg"` 2>$NULL
	# Switch to $WORKDIR/dummysys/var/log
	new_workspace log
	touch dpkg.log lastlog mail.log syslog auth.log daemon.log
	touch faillog lpr.log mail.warn user.log boot debug mail.err messages wtmp
	touch bootstrap.log dmesg kern.log mail.info
	# Switch back to $WORKDIR/dummysys/var
	prev_workspace
	# Switch back to $WORKDIR/dummysys
	prev_workspace
	# remove the non system users on the passwd and group files and
	# copy them to dummysys
	for i in `grep '^[^:]*:[^:]*:[5-9][0-9][0-9]:' /etc/passwd | awk -F: '{print $1}'`
	do
		userdel -f $i
	done
	# Switch to $WORKDIR/dummysys/etc
	new_workspace etc
	grep '^[^:]*:[^:]*:[0-9]:' /etc/passwd >> passwd
	grep '^[^:]*:[^:]*:[0-9][0-9]:' /etc/passwd >> passwd
	grep '^[^:]*:[^:]*:[0-9][0-9][0-9]:' /etc/passwd >> passwd
	grep '^[^:]*:[^:]*:[3-9][0-9][0-9][0-9][0-9]:' /etc/passwd >> passwd
	grep '^[^:]*:[^:]*:[0-9]:' /etc/group >> group
	grep '^[^:]*:[^:]*:[0-9][0-9]:' /etc/group >> group
	grep '^[^:]*:[^:]*:[0-9][0-9][0-9]:' /etc/group >> group
	grep '^[^:]*:[^:]*:[3-9][0-9][0-9][0-9][0-9]:' /etc/group >> group
	grep '^[^:]*:[^:]*:[5-9][0-9][0-9]:' /etc/passwd | awk -F ":" \
	'{print $1}' > $WORKDIR/tmpusers1
	grep '^[^:]*:[^:]*:[1-9][0-9][0-9][0-9]:' /etc/passwd | awk -F ":" \
	'{print $1}' > $WORKDIR/tmpusers2
	grep '^[^:]*:[^:]*:[1-2][0-9][0-9][0-9][0-9]:' /etc/passwd | \
	awk -F ":" '{print $1}' > $WORKDIR/tmpusers3
	cat $WORKDIR/tmpusers1 $WORKDIR/tmpusers2 $WORKDIR/tmpusers3 > \
	$WORKDIR/tmpusers
	while read LINE
	do
		echo $LINE | xargs -i sed -e 's/,{}//g' group > group.new1
		echo $LINE | xargs -i sed -e 's/{},//g' group.new1 > group.new2
		echo $LINE | xargs -i sed -e 's/{}//g' group.new2 > group
		rm -f group.new1 group.new2
	done < $WORKDIR/tmpusers
	rm -f $WORKDIR/tmpusers*
	echo "Done"
	# Switch back to $WORKDIR/dummysys
	prev_workspace
	# Switch back to the directory relinux was run in
	prev_workspace
	############
	## STEP 4 ##
	############
	#
	# Setup ISOLINUX
	box 'STEP 4 of SquashFS'
	echo "Setting up ISOLINUX"
	# Switch to $WORKDIR/ISOTMP
	new_workspace $WORKDIR/ISOTMP
	# Make sure that all casper scripts have exec permissions
	chmod 755 /usr/share/initramfs-tools/scripts/casper-bottom/*
	# Copy the Preseed files
	cp $PRESEED preseed/
	# Copy MemTest86+
	cp /boot/memtest86+.bin isolinux/memtest
	# Check for some files that can come in handy
	if [ ! -f $DIR/customisolinux/isolinux.cfg ]
	then
		# Copy isolinux (bootloader) and vesamenu (graphical menu plugin)
		cp /usr/lib/syslinux/isolinux.bin isolinux/
		cp /usr/lib/syslinux/vesamenu.c32 isolinux/
		ISOLINCFGPATH=isolinux/isolinux.cfg
		# Set CD Label
		sed -e 's/__LIVECDLABEL__/'"$LIVECDLABEL"'/g' $ISOLINUX > $ISOLINCFGPATH
		# Set the splash image
		BSPLASH=`basename $SPLASHIMAGE`
		NSPLASH=`echo $BSPLASH | sed 's:.*\(\..*\):splash\1:g'`
		cp $SPLASHIMAGE $WORKDIR/ISOTMP/isolinux/$NSPLASH
		sed -i 's/__SPLASHIMAGE__/'"$ZASPLASHIMAGE"'/g' $ISOLINCFGPATH
		# Set timeout
		sed -i 's/__TIMEOUT__/'"$LIVECDTIMEOUT"'/g' $ISOLINCFGPATH
	else
		cp $DIR/customisolinux/* isolinux/
	fi
	# Checks the architecture of the system e.g. i386 or amd64
	ARCH=`archdetect | awk -F "/" '{print $1}'`
	# Set C-style disk-definitions
  cat > README.diskdefines << EOF
#define DISKNAME  $LIVECDLABEL - Release $ARCH
#define TYPE  binary
#define TYPEbinary  1
#define ARCH  $ARCH
#define ARCH$ARCH  1
#define DISKNUM  1
#define DISKNUM1  1
#define TOTALNUM  0
#define TOTALNUM0  1
EOF
	cp README.diskdefines casper/README.diskdefines
	# Generate filesystem.manifest (package list)
	echo "Creating filesystem.manifest and filesystem.manifest-desktop"
	dpkg-query -W --showformat='${Package} ${Version}\n' \
	> casper/filesystem.manifest
	cp casper/filesystem.manifest casper/filesystem.manifest-desktop
	# Remove unwanted packages
	for i in $REMOVEAFTERINSTALL
	do
		# Notice that I used # as the delimiter, as /, :, and = are reserved in APT
		sed -i 's#'"$i"'##g' casper/filesystem.manifest-desktop
		echo "$i" >> casper/filesystem.manifest-remove
	done
	echo "Done"
	# Switch back to the directory relinux was run in
	prev_workspace
	# Switch to $WORKDIR/dummysys/etc
	new_workspace $WORKDIR/dummysys/etc
	if parseboolean $GENERATECASPER
	then
		if parseboolean $GENERATELSBRELEASE
		then
			echo "Setting Casper, Ubiquity, and LSB_RELEASE options"
		else
			echo "Setting Capser, and Ubiquity options"
		fi
	else
		if parseboolean $GENERATELSBRELEASE
		then
			echo "Setting Ubiquity, and LSB_RELEASE options"
		else
			echo "Setting Ubiquity options"
		fi
	fi
	if parseboolean $GENERATECASPER
	then
		# Generate casper.conf
		cat << EOF > casper.conf
# This file should go in /etc/casper.conf
# Supported variables are:
# USERNAME, USERFULLNAME, HOST, BUILD_SYSTEM, FLAVOUR

export USERNAME="$LIVEUSER"
export USERFULLNAME="$LIVENAME"
export HOST="$HOSTNAME"
export BUILD_SYSTEM="$SYSNAME"
export FLAVOUR="$HOSTNAME"
EOF
	fi
	if parseboolean $GENERATELSBRELEASE
	then
		# Generate lsb-release
		cat << EOF > lsb-release
DISTRIB_ID="$SYSNAME"
DISTRIB_RELEASE="$SYSVERSION"
DISTRIB_CODENAME="$SYSCODE"
DISTRIB_DESCRIPTION="$SYSDESC"
EOF
	fi
	# Switch back to the directory relinux was run in
	prev_workspace
	# Switch to /usr/lib/ubiquity/user-setup
	new_workspace /usr/lib/ubiquity/user-setup
	# Make sure user-setup-apply is present
	if [ -f user-setup-apply.orig -a ! -f user-setup-apply ]
	then
		cp user-setup-apply.orig user-setup-apply
	fi
	# Switch back to the directory relinux was run in
	prev_workspace
	if not parseboolean $ALLOWCHANGESOURCESLIST
	then
		# Switch to /usr/share/ubiquity
		new_workspace /usr/share/ubiquity
		# Backup apt-setup
		if [ ! -f apt-setup.saved ]
		then
			cp apt-setup apt-setup.saved
		fi
		# Empty apt-setup
		emptyfile apt-setup
		chmod 0755 apt-setup
	else
		# Switch to /usr/lib/ubiquity
		new_workspace /usr/lib/ubiquity
		# Bug in ubiquity or casper, so we need to remove APT CDROM support
		# Backup 40cdrom
		if [ ! -f 40cdrom.saved ]
		then
			cp apt-setup/generators/40cdrom	40cdrom.saved
		fi
		# Remove it
		rm -f apt-setup/generators/40cdrom
	fi
	# Switch back to the directory relinux was run in
	prev_workspace
	echo "Done"
	# Switch to $WORKDIR/ISOTMP/casper
	new_workspace $WORKDIR/ISOTMP/casper
	echo "Copying your kernel and initrd to the livecd"
	# Set the kernel version to the current kernel
	KERNVERSION=`uname -r`
	# Make a new initial ramdisk
	mkinitramfs -o initrd.gz $KERNVERSION
	# Copy linux kernel to casper
	cp /boot/vmlinuz-$KERNVERSION vmlinuz
	echo "Done"
	############
	## STEP 5 ##
	############
	#
	# Create SquashFS file
	box 'STEP 5 of SquashFS'
	echo "Creating filesystem.squashfs"
	echo "This will take a while so be patient"
	# Remove the old filesystem.squashfs (if it exists)
	rm -f filesystem.squashfs
	# Set general options for SquashFS
	SQUASHFSOPTSHIGH="-no-recovery -always-use-fragments -b 1M -no-duplicates"
	echo "Adding stage 1 files/folders that the livecd requires."
	# Add the blank folders and the edited /var and /etc to the SquashFS file
	mksquashfs $WORKDIR/dummysys/ filesystem.squashfs $SQUASHFSOPTSHIGH
	echo "Adding stage 2 files/folders that the livecd requires."
	echo "This will probably take longer than the first stage."
	# Add the rest of the system
	EXHOME=""
	if not parseboolean $BACKUPMODE
	then
		EXHOME="home"
	fi
	# Append / to the SquashFS file
	mksquashfs / filesystem.squashfs $SQUASHFSOPTSHIGH \
	-e .thumbnails .cache .bash_history Cache boot/grub dev etc media mnt proc \
	sys var $EXHOME $WORKDIR $EXCLUDES
	# Switch back to the directory relinux was run in
	prev_workspace
	# Just in case something goes wrong
	EXITCMD=""
	# Make sure that the SquashFS file is OK
	do_squashfs_checks
	if rete $?
	then
		# Add filesystem size
		echo "Calculating the installed filesystem size for the installer"
		SIZEFILE=`tempfile`
		unsquashfs -lls filesystem.squashfs | \
		grep -v " inodes " | grep -v "unsquashfs:" | \
		awk '{print $3}' | grep -v "," > $SIZEFILE
		for i in `cat $SIZEFILE`
		do
			if isnumber $i
			then
				a=$(($a+$i))
			fi
		done
		echo $a > filesystem.size
		rm -f $SIZEFILE
		echo "Done"
		echo "Finished generating SquashFS file."
	else
		EXITCMD="exit 1"
	fi
	echo "Reverting filesystem changes"
	if [ -f "/usr/share/ubiquity/apt-setup.saved" ]
	then
		mv /usr/share/ubiquity/apt-setup.saved /usr/share/ubiquity/apt-setup
	fi
	if [ -f "/usr/lib/ubiquity/40cdrom.saved" ]
	then
		mv /usr/lib/ubiquity/40cdrom.saved /usr/lib/ubiquity/apt-setup/generators/40cdrom
	fi
	echo "Done"
	$EXITCMD
}
# Generate the ISO file from the function above
iso()
{
	############
	## STEP 1 ##
	############
	#
	# Detect tools for ISO Generation
	box 'STEP 1 of ISO Generation'
	echo "Detecting your tools for ISO generation"
	CREATEISO="`which genisoimage`"
	if [[ "$CREATEISO" == "" ]]; then
		CREATEISO="`which mkisofs`"
	fi
	echo "Done"
	############
	## STEP 2 ##
	############
	#
	# Verify the SquashFS file
	box 'STEP 2 of ISO Generation'
	echo "Verifying your SquashFS file"
	# Make sure the SquashFS file is ok
	do_squashfs_checks
	if not rete $?
	then
		exit 1
	fi
	echo "Done. No errors."
	############
	## STEP 3 ##
	############
	#
	# Make the ISO compatible with Ubuntu Startup Disk Creator
	box 'STEP 3 of ISO Generation'
	echo "Making disk compatible with Ubuntu Startup Disk Creator."
	touch $WORKDIR/ISOTMP/ubuntu
	touch $WORKDIR/ISOTMP/.disk/base_installable
	echo "full_cd/single" > $WORKDIR/ISOTMP/.disk/cd_type
	ARCH=`archdetect | awk -F "/" '{print $1}'`
	echo "$LIVECDLABEL - Release $ARCH" > $WORKDIR/ISOTMP/.disk/info
	echo "$LIVECDURL" > $WORKDIR/ISOTMP/.disk/release_notes_url
	############
	## STEP 4 ##
	############
	#
	# Make the MD5 Sums
	box 'STEP 4 of ISO Generation'
	echo "Making temporary MD5 Sums for generation of the ISO file"
	# Switch to $WORKDIR/ISOTMP
	new_workspace $WORKDIR/ISOTMP
	md5sum `find . -type f` > md5sum.txt
	# Remove files that change and cause problems with checking the disk
	sed -i 's/.*isolinux.*//g' md5sum.txt
	sed -i 's/.*md5sum.*//g' md5sum.txt
	# Switch back to the directory relinux was run in
	prev_workspace
	############
	## STEP 5 ##
	############
	#
	# Create the ISO file and MD5 sum
	box 'STEP 5 of ISO Generation (final step)'
	echo "Creating the ISO file and MD5 sum for it"
	echo "Creating $CUSTOMISO in $WORKDIR"
	$CREATEISO -quiet -r -V "$LIVECDLABEL" -cache-inodes -J -l \
	-b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot \
	-boot-load-size 4 -boot-info-table -o $WORKDIR/$CUSTOMISO \
	"$WORKDIR/ISOTMP" &>$NULL
	# Create the MD5 sum
	echo "Creating $CUSTOMISO.md5 in $WORKDIR"
	# Switch to $WORKDIR
	new_workspace $WORKDIR
	md5sum $CUSTOMISO > $CUSTOMISO.md5
	# Switch back to the directory relinux was run in
	prev_workspace
	echo "Done"
	echo
	echo "$WORKDIR/$CUSTOMISO is generated. It is recommended to run it"\
	" inside a virtual machine before you release it."
	echo
	echo "The size of $WORKDIR/$CUSTOMISO is "\
	"`ls -hs $WORKDIR/$CUSTOMISO | awk '{print $1}'`"
	ISOSIZE="`wc -c $WORKDIR/$CUSTOMISO | awk '{print $1}'`"
	if [ $ISOSIZE -ge 734003200 ]
	then
		echo "You will need to burn a DVD/USB/Blu-Ray disk instead of a CD."
	fi
	echo
	echo "It is recommended to run 'sudo relinux clean' (without quotes)"\
	" once you have burned and tested $CUSTOMISO"
	echo "It will not delete $CUSTOMISO or $CUSTOMISO.md5"
	echo
}

if [[ "$1" == "clean" ]]
then
	echo "Cleaning..."
	rm -rf $WORKDIR/dummysys &>$NULL
	rm -rf $WORKDIR/ISOTMP &>$NULL
	rm -f $WORKDIR/.filesystem.squashfs.* &>$NULL
	echo "Done"
	exit 0
elif [[ "$1" == "fullclean" ]]
then
	echo "Cleaning..."
	rm -rf $WORKDIR
	echo "Done"
	exit 0
elif [[ "$1" == "squashfs" ]]
then
	cdfs $@
	exit 0
elif [[ "$1" == "onlyiso" ]]
then
	iso $@
	exit 0
elif [[ "$1" == "config" ]]
then
	echo "Generating configuration file..."
	cp /etc/relinux/relinux.conf ./relinux.conf
	sed -i \
	's:EXCLUDES="\(.*\)":EXCLUDES="\1 '`readlink -f ./relinux.conf`'":g' \
	./relinux.conf
	chmod 0666 ./relinux.conf
	echo "Done. File is located here: `readlink -f ./relinux.conf`"
	exit 0
elif [[ "$1" == "iso" ]]
then
	cdfs $@
	iso $@
	exit 0
else
	usage
	exit 1
fi

wutmsg
